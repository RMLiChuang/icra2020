// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: armor_detection.proto

#ifndef PROTOBUF_armor_5fdetection_2eproto__INCLUDED
#define PROTOBUF_armor_5fdetection_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace roborts_detection {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_armor_5fdetection_2eproto();
void protobuf_AssignDesc_armor_5fdetection_2eproto();
void protobuf_ShutdownFile_armor_5fdetection_2eproto();

class CameraGimbalTransform;
class ProjectileModelInfo;
class ArmorDetectionAlgorithms;

// ===================================================================

class CameraGimbalTransform : public ::google::protobuf::Message {
 public:
  CameraGimbalTransform();
  virtual ~CameraGimbalTransform();

  CameraGimbalTransform(const CameraGimbalTransform& from);

  inline CameraGimbalTransform& operator=(const CameraGimbalTransform& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CameraGimbalTransform& default_instance();

  void Swap(CameraGimbalTransform* other);

  // implements Message ----------------------------------------------

  CameraGimbalTransform* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CameraGimbalTransform& from);
  void MergeFrom(const CameraGimbalTransform& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float offset_x = 1;
  inline bool has_offset_x() const;
  inline void clear_offset_x();
  static const int kOffsetXFieldNumber = 1;
  inline float offset_x() const;
  inline void set_offset_x(float value);

  // required float offset_y = 2;
  inline bool has_offset_y() const;
  inline void clear_offset_y();
  static const int kOffsetYFieldNumber = 2;
  inline float offset_y() const;
  inline void set_offset_y(float value);

  // required float offset_z = 3;
  inline bool has_offset_z() const;
  inline void clear_offset_z();
  static const int kOffsetZFieldNumber = 3;
  inline float offset_z() const;
  inline void set_offset_z(float value);

  // required float offset_pitch = 4;
  inline bool has_offset_pitch() const;
  inline void clear_offset_pitch();
  static const int kOffsetPitchFieldNumber = 4;
  inline float offset_pitch() const;
  inline void set_offset_pitch(float value);

  // required float offset_yaw = 5;
  inline bool has_offset_yaw() const;
  inline void clear_offset_yaw();
  static const int kOffsetYawFieldNumber = 5;
  inline float offset_yaw() const;
  inline void set_offset_yaw(float value);

  // @@protoc_insertion_point(class_scope:roborts_detection.CameraGimbalTransform)
 private:
  inline void set_has_offset_x();
  inline void clear_has_offset_x();
  inline void set_has_offset_y();
  inline void clear_has_offset_y();
  inline void set_has_offset_z();
  inline void clear_has_offset_z();
  inline void set_has_offset_pitch();
  inline void clear_has_offset_pitch();
  inline void set_has_offset_yaw();
  inline void clear_has_offset_yaw();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float offset_x_;
  float offset_y_;
  float offset_z_;
  float offset_pitch_;
  float offset_yaw_;
  friend void  protobuf_AddDesc_armor_5fdetection_2eproto();
  friend void protobuf_AssignDesc_armor_5fdetection_2eproto();
  friend void protobuf_ShutdownFile_armor_5fdetection_2eproto();

  void InitAsDefaultInstance();
  static CameraGimbalTransform* default_instance_;
};
// -------------------------------------------------------------------

class ProjectileModelInfo : public ::google::protobuf::Message {
 public:
  ProjectileModelInfo();
  virtual ~ProjectileModelInfo();

  ProjectileModelInfo(const ProjectileModelInfo& from);

  inline ProjectileModelInfo& operator=(const ProjectileModelInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProjectileModelInfo& default_instance();

  void Swap(ProjectileModelInfo* other);

  // implements Message ----------------------------------------------

  ProjectileModelInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProjectileModelInfo& from);
  void MergeFrom(const ProjectileModelInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float init_v = 1;
  inline bool has_init_v() const;
  inline void clear_init_v();
  static const int kInitVFieldNumber = 1;
  inline float init_v() const;
  inline void set_init_v(float value);

  // optional float init_k = 2;
  inline bool has_init_k() const;
  inline void clear_init_k();
  static const int kInitKFieldNumber = 2;
  inline float init_k() const;
  inline void set_init_k(float value);

  // @@protoc_insertion_point(class_scope:roborts_detection.ProjectileModelInfo)
 private:
  inline void set_has_init_v();
  inline void clear_has_init_v();
  inline void set_has_init_k();
  inline void clear_has_init_k();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float init_v_;
  float init_k_;
  friend void  protobuf_AddDesc_armor_5fdetection_2eproto();
  friend void protobuf_AssignDesc_armor_5fdetection_2eproto();
  friend void protobuf_ShutdownFile_armor_5fdetection_2eproto();

  void InitAsDefaultInstance();
  static ProjectileModelInfo* default_instance_;
};
// -------------------------------------------------------------------

class ArmorDetectionAlgorithms : public ::google::protobuf::Message {
 public:
  ArmorDetectionAlgorithms();
  virtual ~ArmorDetectionAlgorithms();

  ArmorDetectionAlgorithms(const ArmorDetectionAlgorithms& from);

  inline ArmorDetectionAlgorithms& operator=(const ArmorDetectionAlgorithms& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ArmorDetectionAlgorithms& default_instance();

  void Swap(ArmorDetectionAlgorithms* other);

  // implements Message ----------------------------------------------

  ArmorDetectionAlgorithms* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ArmorDetectionAlgorithms& from);
  void MergeFrom(const ArmorDetectionAlgorithms& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string name = 1;
  inline int name_size() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name(int index) const;
  inline ::std::string* mutable_name(int index);
  inline void set_name(int index, const ::std::string& value);
  inline void set_name(int index, const char* value);
  inline void set_name(int index, const char* value, size_t size);
  inline ::std::string* add_name();
  inline void add_name(const ::std::string& value);
  inline void add_name(const char* value);
  inline void add_name(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& name() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_name();

  // optional string selected_algorithm = 2;
  inline bool has_selected_algorithm() const;
  inline void clear_selected_algorithm();
  static const int kSelectedAlgorithmFieldNumber = 2;
  inline const ::std::string& selected_algorithm() const;
  inline void set_selected_algorithm(const ::std::string& value);
  inline void set_selected_algorithm(const char* value);
  inline void set_selected_algorithm(const char* value, size_t size);
  inline ::std::string* mutable_selected_algorithm();
  inline ::std::string* release_selected_algorithm();
  inline void set_allocated_selected_algorithm(::std::string* selected_algorithm);

  // optional uint32 undetected_armor_delay = 3;
  inline bool has_undetected_armor_delay() const;
  inline void clear_undetected_armor_delay();
  static const int kUndetectedArmorDelayFieldNumber = 3;
  inline ::google::protobuf::uint32 undetected_armor_delay() const;
  inline void set_undetected_armor_delay(::google::protobuf::uint32 value);

  // optional string camera_name = 4;
  inline bool has_camera_name() const;
  inline void clear_camera_name();
  static const int kCameraNameFieldNumber = 4;
  inline const ::std::string& camera_name() const;
  inline void set_camera_name(const ::std::string& value);
  inline void set_camera_name(const char* value);
  inline void set_camera_name(const char* value, size_t size);
  inline ::std::string* mutable_camera_name();
  inline ::std::string* release_camera_name();
  inline void set_allocated_camera_name(::std::string* camera_name);

  // required .roborts_detection.CameraGimbalTransform camera_gimbal_transform = 5;
  inline bool has_camera_gimbal_transform() const;
  inline void clear_camera_gimbal_transform();
  static const int kCameraGimbalTransformFieldNumber = 5;
  inline const ::roborts_detection::CameraGimbalTransform& camera_gimbal_transform() const;
  inline ::roborts_detection::CameraGimbalTransform* mutable_camera_gimbal_transform();
  inline ::roborts_detection::CameraGimbalTransform* release_camera_gimbal_transform();
  inline void set_allocated_camera_gimbal_transform(::roborts_detection::CameraGimbalTransform* camera_gimbal_transform);

  // optional .roborts_detection.ProjectileModelInfo projectile_model_info = 6;
  inline bool has_projectile_model_info() const;
  inline void clear_projectile_model_info();
  static const int kProjectileModelInfoFieldNumber = 6;
  inline const ::roborts_detection::ProjectileModelInfo& projectile_model_info() const;
  inline ::roborts_detection::ProjectileModelInfo* mutable_projectile_model_info();
  inline ::roborts_detection::ProjectileModelInfo* release_projectile_model_info();
  inline void set_allocated_projectile_model_info(::roborts_detection::ProjectileModelInfo* projectile_model_info);

  // @@protoc_insertion_point(class_scope:roborts_detection.ArmorDetectionAlgorithms)
 private:
  inline void set_has_selected_algorithm();
  inline void clear_has_selected_algorithm();
  inline void set_has_undetected_armor_delay();
  inline void clear_has_undetected_armor_delay();
  inline void set_has_camera_name();
  inline void clear_has_camera_name();
  inline void set_has_camera_gimbal_transform();
  inline void clear_has_camera_gimbal_transform();
  inline void set_has_projectile_model_info();
  inline void clear_has_projectile_model_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> name_;
  ::std::string* selected_algorithm_;
  ::std::string* camera_name_;
  ::roborts_detection::CameraGimbalTransform* camera_gimbal_transform_;
  ::roborts_detection::ProjectileModelInfo* projectile_model_info_;
  ::google::protobuf::uint32 undetected_armor_delay_;
  friend void  protobuf_AddDesc_armor_5fdetection_2eproto();
  friend void protobuf_AssignDesc_armor_5fdetection_2eproto();
  friend void protobuf_ShutdownFile_armor_5fdetection_2eproto();

  void InitAsDefaultInstance();
  static ArmorDetectionAlgorithms* default_instance_;
};
// ===================================================================


// ===================================================================

// CameraGimbalTransform

// required float offset_x = 1;
inline bool CameraGimbalTransform::has_offset_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CameraGimbalTransform::set_has_offset_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CameraGimbalTransform::clear_has_offset_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CameraGimbalTransform::clear_offset_x() {
  offset_x_ = 0;
  clear_has_offset_x();
}
inline float CameraGimbalTransform::offset_x() const {
  // @@protoc_insertion_point(field_get:roborts_detection.CameraGimbalTransform.offset_x)
  return offset_x_;
}
inline void CameraGimbalTransform::set_offset_x(float value) {
  set_has_offset_x();
  offset_x_ = value;
  // @@protoc_insertion_point(field_set:roborts_detection.CameraGimbalTransform.offset_x)
}

// required float offset_y = 2;
inline bool CameraGimbalTransform::has_offset_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CameraGimbalTransform::set_has_offset_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CameraGimbalTransform::clear_has_offset_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CameraGimbalTransform::clear_offset_y() {
  offset_y_ = 0;
  clear_has_offset_y();
}
inline float CameraGimbalTransform::offset_y() const {
  // @@protoc_insertion_point(field_get:roborts_detection.CameraGimbalTransform.offset_y)
  return offset_y_;
}
inline void CameraGimbalTransform::set_offset_y(float value) {
  set_has_offset_y();
  offset_y_ = value;
  // @@protoc_insertion_point(field_set:roborts_detection.CameraGimbalTransform.offset_y)
}

// required float offset_z = 3;
inline bool CameraGimbalTransform::has_offset_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CameraGimbalTransform::set_has_offset_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CameraGimbalTransform::clear_has_offset_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CameraGimbalTransform::clear_offset_z() {
  offset_z_ = 0;
  clear_has_offset_z();
}
inline float CameraGimbalTransform::offset_z() const {
  // @@protoc_insertion_point(field_get:roborts_detection.CameraGimbalTransform.offset_z)
  return offset_z_;
}
inline void CameraGimbalTransform::set_offset_z(float value) {
  set_has_offset_z();
  offset_z_ = value;
  // @@protoc_insertion_point(field_set:roborts_detection.CameraGimbalTransform.offset_z)
}

// required float offset_pitch = 4;
inline bool CameraGimbalTransform::has_offset_pitch() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CameraGimbalTransform::set_has_offset_pitch() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CameraGimbalTransform::clear_has_offset_pitch() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CameraGimbalTransform::clear_offset_pitch() {
  offset_pitch_ = 0;
  clear_has_offset_pitch();
}
inline float CameraGimbalTransform::offset_pitch() const {
  // @@protoc_insertion_point(field_get:roborts_detection.CameraGimbalTransform.offset_pitch)
  return offset_pitch_;
}
inline void CameraGimbalTransform::set_offset_pitch(float value) {
  set_has_offset_pitch();
  offset_pitch_ = value;
  // @@protoc_insertion_point(field_set:roborts_detection.CameraGimbalTransform.offset_pitch)
}

// required float offset_yaw = 5;
inline bool CameraGimbalTransform::has_offset_yaw() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CameraGimbalTransform::set_has_offset_yaw() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CameraGimbalTransform::clear_has_offset_yaw() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CameraGimbalTransform::clear_offset_yaw() {
  offset_yaw_ = 0;
  clear_has_offset_yaw();
}
inline float CameraGimbalTransform::offset_yaw() const {
  // @@protoc_insertion_point(field_get:roborts_detection.CameraGimbalTransform.offset_yaw)
  return offset_yaw_;
}
inline void CameraGimbalTransform::set_offset_yaw(float value) {
  set_has_offset_yaw();
  offset_yaw_ = value;
  // @@protoc_insertion_point(field_set:roborts_detection.CameraGimbalTransform.offset_yaw)
}

// -------------------------------------------------------------------

// ProjectileModelInfo

// optional float init_v = 1;
inline bool ProjectileModelInfo::has_init_v() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProjectileModelInfo::set_has_init_v() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProjectileModelInfo::clear_has_init_v() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProjectileModelInfo::clear_init_v() {
  init_v_ = 0;
  clear_has_init_v();
}
inline float ProjectileModelInfo::init_v() const {
  // @@protoc_insertion_point(field_get:roborts_detection.ProjectileModelInfo.init_v)
  return init_v_;
}
inline void ProjectileModelInfo::set_init_v(float value) {
  set_has_init_v();
  init_v_ = value;
  // @@protoc_insertion_point(field_set:roborts_detection.ProjectileModelInfo.init_v)
}

// optional float init_k = 2;
inline bool ProjectileModelInfo::has_init_k() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProjectileModelInfo::set_has_init_k() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProjectileModelInfo::clear_has_init_k() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProjectileModelInfo::clear_init_k() {
  init_k_ = 0;
  clear_has_init_k();
}
inline float ProjectileModelInfo::init_k() const {
  // @@protoc_insertion_point(field_get:roborts_detection.ProjectileModelInfo.init_k)
  return init_k_;
}
inline void ProjectileModelInfo::set_init_k(float value) {
  set_has_init_k();
  init_k_ = value;
  // @@protoc_insertion_point(field_set:roborts_detection.ProjectileModelInfo.init_k)
}

// -------------------------------------------------------------------

// ArmorDetectionAlgorithms

// repeated string name = 1;
inline int ArmorDetectionAlgorithms::name_size() const {
  return name_.size();
}
inline void ArmorDetectionAlgorithms::clear_name() {
  name_.Clear();
}
inline const ::std::string& ArmorDetectionAlgorithms::name(int index) const {
  // @@protoc_insertion_point(field_get:roborts_detection.ArmorDetectionAlgorithms.name)
  return name_.Get(index);
}
inline ::std::string* ArmorDetectionAlgorithms::mutable_name(int index) {
  // @@protoc_insertion_point(field_mutable:roborts_detection.ArmorDetectionAlgorithms.name)
  return name_.Mutable(index);
}
inline void ArmorDetectionAlgorithms::set_name(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:roborts_detection.ArmorDetectionAlgorithms.name)
  name_.Mutable(index)->assign(value);
}
inline void ArmorDetectionAlgorithms::set_name(int index, const char* value) {
  name_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:roborts_detection.ArmorDetectionAlgorithms.name)
}
inline void ArmorDetectionAlgorithms::set_name(int index, const char* value, size_t size) {
  name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:roborts_detection.ArmorDetectionAlgorithms.name)
}
inline ::std::string* ArmorDetectionAlgorithms::add_name() {
  return name_.Add();
}
inline void ArmorDetectionAlgorithms::add_name(const ::std::string& value) {
  name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:roborts_detection.ArmorDetectionAlgorithms.name)
}
inline void ArmorDetectionAlgorithms::add_name(const char* value) {
  name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:roborts_detection.ArmorDetectionAlgorithms.name)
}
inline void ArmorDetectionAlgorithms::add_name(const char* value, size_t size) {
  name_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:roborts_detection.ArmorDetectionAlgorithms.name)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ArmorDetectionAlgorithms::name() const {
  // @@protoc_insertion_point(field_list:roborts_detection.ArmorDetectionAlgorithms.name)
  return name_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ArmorDetectionAlgorithms::mutable_name() {
  // @@protoc_insertion_point(field_mutable_list:roborts_detection.ArmorDetectionAlgorithms.name)
  return &name_;
}

// optional string selected_algorithm = 2;
inline bool ArmorDetectionAlgorithms::has_selected_algorithm() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ArmorDetectionAlgorithms::set_has_selected_algorithm() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ArmorDetectionAlgorithms::clear_has_selected_algorithm() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ArmorDetectionAlgorithms::clear_selected_algorithm() {
  if (selected_algorithm_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    selected_algorithm_->clear();
  }
  clear_has_selected_algorithm();
}
inline const ::std::string& ArmorDetectionAlgorithms::selected_algorithm() const {
  // @@protoc_insertion_point(field_get:roborts_detection.ArmorDetectionAlgorithms.selected_algorithm)
  return *selected_algorithm_;
}
inline void ArmorDetectionAlgorithms::set_selected_algorithm(const ::std::string& value) {
  set_has_selected_algorithm();
  if (selected_algorithm_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    selected_algorithm_ = new ::std::string;
  }
  selected_algorithm_->assign(value);
  // @@protoc_insertion_point(field_set:roborts_detection.ArmorDetectionAlgorithms.selected_algorithm)
}
inline void ArmorDetectionAlgorithms::set_selected_algorithm(const char* value) {
  set_has_selected_algorithm();
  if (selected_algorithm_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    selected_algorithm_ = new ::std::string;
  }
  selected_algorithm_->assign(value);
  // @@protoc_insertion_point(field_set_char:roborts_detection.ArmorDetectionAlgorithms.selected_algorithm)
}
inline void ArmorDetectionAlgorithms::set_selected_algorithm(const char* value, size_t size) {
  set_has_selected_algorithm();
  if (selected_algorithm_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    selected_algorithm_ = new ::std::string;
  }
  selected_algorithm_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:roborts_detection.ArmorDetectionAlgorithms.selected_algorithm)
}
inline ::std::string* ArmorDetectionAlgorithms::mutable_selected_algorithm() {
  set_has_selected_algorithm();
  if (selected_algorithm_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    selected_algorithm_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:roborts_detection.ArmorDetectionAlgorithms.selected_algorithm)
  return selected_algorithm_;
}
inline ::std::string* ArmorDetectionAlgorithms::release_selected_algorithm() {
  clear_has_selected_algorithm();
  if (selected_algorithm_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = selected_algorithm_;
    selected_algorithm_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ArmorDetectionAlgorithms::set_allocated_selected_algorithm(::std::string* selected_algorithm) {
  if (selected_algorithm_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete selected_algorithm_;
  }
  if (selected_algorithm) {
    set_has_selected_algorithm();
    selected_algorithm_ = selected_algorithm;
  } else {
    clear_has_selected_algorithm();
    selected_algorithm_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:roborts_detection.ArmorDetectionAlgorithms.selected_algorithm)
}

// optional uint32 undetected_armor_delay = 3;
inline bool ArmorDetectionAlgorithms::has_undetected_armor_delay() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ArmorDetectionAlgorithms::set_has_undetected_armor_delay() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ArmorDetectionAlgorithms::clear_has_undetected_armor_delay() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ArmorDetectionAlgorithms::clear_undetected_armor_delay() {
  undetected_armor_delay_ = 0u;
  clear_has_undetected_armor_delay();
}
inline ::google::protobuf::uint32 ArmorDetectionAlgorithms::undetected_armor_delay() const {
  // @@protoc_insertion_point(field_get:roborts_detection.ArmorDetectionAlgorithms.undetected_armor_delay)
  return undetected_armor_delay_;
}
inline void ArmorDetectionAlgorithms::set_undetected_armor_delay(::google::protobuf::uint32 value) {
  set_has_undetected_armor_delay();
  undetected_armor_delay_ = value;
  // @@protoc_insertion_point(field_set:roborts_detection.ArmorDetectionAlgorithms.undetected_armor_delay)
}

// optional string camera_name = 4;
inline bool ArmorDetectionAlgorithms::has_camera_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ArmorDetectionAlgorithms::set_has_camera_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ArmorDetectionAlgorithms::clear_has_camera_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ArmorDetectionAlgorithms::clear_camera_name() {
  if (camera_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    camera_name_->clear();
  }
  clear_has_camera_name();
}
inline const ::std::string& ArmorDetectionAlgorithms::camera_name() const {
  // @@protoc_insertion_point(field_get:roborts_detection.ArmorDetectionAlgorithms.camera_name)
  return *camera_name_;
}
inline void ArmorDetectionAlgorithms::set_camera_name(const ::std::string& value) {
  set_has_camera_name();
  if (camera_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    camera_name_ = new ::std::string;
  }
  camera_name_->assign(value);
  // @@protoc_insertion_point(field_set:roborts_detection.ArmorDetectionAlgorithms.camera_name)
}
inline void ArmorDetectionAlgorithms::set_camera_name(const char* value) {
  set_has_camera_name();
  if (camera_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    camera_name_ = new ::std::string;
  }
  camera_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:roborts_detection.ArmorDetectionAlgorithms.camera_name)
}
inline void ArmorDetectionAlgorithms::set_camera_name(const char* value, size_t size) {
  set_has_camera_name();
  if (camera_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    camera_name_ = new ::std::string;
  }
  camera_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:roborts_detection.ArmorDetectionAlgorithms.camera_name)
}
inline ::std::string* ArmorDetectionAlgorithms::mutable_camera_name() {
  set_has_camera_name();
  if (camera_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    camera_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:roborts_detection.ArmorDetectionAlgorithms.camera_name)
  return camera_name_;
}
inline ::std::string* ArmorDetectionAlgorithms::release_camera_name() {
  clear_has_camera_name();
  if (camera_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = camera_name_;
    camera_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ArmorDetectionAlgorithms::set_allocated_camera_name(::std::string* camera_name) {
  if (camera_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete camera_name_;
  }
  if (camera_name) {
    set_has_camera_name();
    camera_name_ = camera_name;
  } else {
    clear_has_camera_name();
    camera_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:roborts_detection.ArmorDetectionAlgorithms.camera_name)
}

// required .roborts_detection.CameraGimbalTransform camera_gimbal_transform = 5;
inline bool ArmorDetectionAlgorithms::has_camera_gimbal_transform() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ArmorDetectionAlgorithms::set_has_camera_gimbal_transform() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ArmorDetectionAlgorithms::clear_has_camera_gimbal_transform() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ArmorDetectionAlgorithms::clear_camera_gimbal_transform() {
  if (camera_gimbal_transform_ != NULL) camera_gimbal_transform_->::roborts_detection::CameraGimbalTransform::Clear();
  clear_has_camera_gimbal_transform();
}
inline const ::roborts_detection::CameraGimbalTransform& ArmorDetectionAlgorithms::camera_gimbal_transform() const {
  // @@protoc_insertion_point(field_get:roborts_detection.ArmorDetectionAlgorithms.camera_gimbal_transform)
  return camera_gimbal_transform_ != NULL ? *camera_gimbal_transform_ : *default_instance_->camera_gimbal_transform_;
}
inline ::roborts_detection::CameraGimbalTransform* ArmorDetectionAlgorithms::mutable_camera_gimbal_transform() {
  set_has_camera_gimbal_transform();
  if (camera_gimbal_transform_ == NULL) camera_gimbal_transform_ = new ::roborts_detection::CameraGimbalTransform;
  // @@protoc_insertion_point(field_mutable:roborts_detection.ArmorDetectionAlgorithms.camera_gimbal_transform)
  return camera_gimbal_transform_;
}
inline ::roborts_detection::CameraGimbalTransform* ArmorDetectionAlgorithms::release_camera_gimbal_transform() {
  clear_has_camera_gimbal_transform();
  ::roborts_detection::CameraGimbalTransform* temp = camera_gimbal_transform_;
  camera_gimbal_transform_ = NULL;
  return temp;
}
inline void ArmorDetectionAlgorithms::set_allocated_camera_gimbal_transform(::roborts_detection::CameraGimbalTransform* camera_gimbal_transform) {
  delete camera_gimbal_transform_;
  camera_gimbal_transform_ = camera_gimbal_transform;
  if (camera_gimbal_transform) {
    set_has_camera_gimbal_transform();
  } else {
    clear_has_camera_gimbal_transform();
  }
  // @@protoc_insertion_point(field_set_allocated:roborts_detection.ArmorDetectionAlgorithms.camera_gimbal_transform)
}

// optional .roborts_detection.ProjectileModelInfo projectile_model_info = 6;
inline bool ArmorDetectionAlgorithms::has_projectile_model_info() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ArmorDetectionAlgorithms::set_has_projectile_model_info() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ArmorDetectionAlgorithms::clear_has_projectile_model_info() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ArmorDetectionAlgorithms::clear_projectile_model_info() {
  if (projectile_model_info_ != NULL) projectile_model_info_->::roborts_detection::ProjectileModelInfo::Clear();
  clear_has_projectile_model_info();
}
inline const ::roborts_detection::ProjectileModelInfo& ArmorDetectionAlgorithms::projectile_model_info() const {
  // @@protoc_insertion_point(field_get:roborts_detection.ArmorDetectionAlgorithms.projectile_model_info)
  return projectile_model_info_ != NULL ? *projectile_model_info_ : *default_instance_->projectile_model_info_;
}
inline ::roborts_detection::ProjectileModelInfo* ArmorDetectionAlgorithms::mutable_projectile_model_info() {
  set_has_projectile_model_info();
  if (projectile_model_info_ == NULL) projectile_model_info_ = new ::roborts_detection::ProjectileModelInfo;
  // @@protoc_insertion_point(field_mutable:roborts_detection.ArmorDetectionAlgorithms.projectile_model_info)
  return projectile_model_info_;
}
inline ::roborts_detection::ProjectileModelInfo* ArmorDetectionAlgorithms::release_projectile_model_info() {
  clear_has_projectile_model_info();
  ::roborts_detection::ProjectileModelInfo* temp = projectile_model_info_;
  projectile_model_info_ = NULL;
  return temp;
}
inline void ArmorDetectionAlgorithms::set_allocated_projectile_model_info(::roborts_detection::ProjectileModelInfo* projectile_model_info) {
  delete projectile_model_info_;
  projectile_model_info_ = projectile_model_info;
  if (projectile_model_info) {
    set_has_projectile_model_info();
  } else {
    clear_has_projectile_model_info();
  }
  // @@protoc_insertion_point(field_set_allocated:roborts_detection.ArmorDetectionAlgorithms.projectile_model_info)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace roborts_detection

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_armor_5fdetection_2eproto__INCLUDED
